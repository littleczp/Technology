# 缓存问题

{% tabs %}
{% tab title="缓存雪崩" %}
<table><thead><tr><th width="159.291259765625">术语</th><th width="551.1198120117188">原理</th></tr></thead><tbody><tr><td>Cache Avalanche</td><td><p>设置缓存时采用了相同的过期时间，</p><p>导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩</p></td></tr></tbody></table>
{% endtab %}

{% tab title="缓存击穿" %}

{% endtab %}

{% tab title="缓存穿透" %}

{% endtab %}
{% endtabs %}

{% tabs %}
{% tab title="缓存雪崩" %}
事前：

1. 均匀过期：在原有的失效时间基础上增加一个随机值（1-5分钟随机），使得每一个缓存的过期时间的重复率降低
2. 分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同
3. 保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题：可以使用 主从 + 哨兵，Redis集群来避免 Redis 全盘崩溃的情况
4. 缓存预热，提前将相关的缓存数据加载到缓存系统

&#x20;

事中：

1. 互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
2. 使用熔断机制，限流降级：当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果

&#x20;

事后：开启Redis持久化机制(AOF)，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据
{% endtab %}

{% tab title="缓存击穿" %}
1. 在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量
2. 缓存不过期：
   1. 物理不过期，针对热点key不设置过期时间
   2. 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建
{% endtab %}

{% tab title="缓存穿透" %}
1. 将无效的key存放进Redis中，返回空值
2.  使用布隆过滤器：如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在。

    如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)
{% endtab %}
{% endtabs %}

